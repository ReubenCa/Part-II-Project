package com.carolang;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.carolang.common.agent_types.AgentType;
import com.carolang.common.agent_types.DataAgentType;
import com.carolang.common.agent_types.NonDataAgentType;
import com.carolang.common.data_sources.ConstantData;
import com.carolang.common.data_sources.DataAgentImplementation;
import com.carolang.common.data_sources.DataSource;
import com.carolang.common.types.FunctionType;
import com.carolang.common.types.ListType;
import com.carolang.common.types.Type;
import com.carolang.common.interaction_rules.AgentImplementationBase;
import com.carolang.common.interaction_rules.Port;
import com.carolang.common.interaction_rules.ProgramBase;
import com.carolang.common.interaction_rules.RewriteRule;
import com.carolang.common.interaction_rules.Wire;
import com.carolang.common.ast_nodes.BooleanNode;
import com.carolang.common.ast_nodes.ConsNode;
import com.carolang.common.ast_nodes.EmptyListNode;
import com.carolang.common.ast_nodes.FloatNode;
import com.carolang.common.ast_nodes.FunctionArgumentNode;
import com.carolang.common.ast_nodes.FunctionNode;
import com.carolang.common.ast_nodes.IfNode;
import com.carolang.common.ast_nodes.IntegerNode;
import com.carolang.common.ast_nodes.LambdaNode;
import com.carolang.common.ast_nodes.MagicNode;
import com.carolang.common.ast_nodes.MagicNodeTag;
import com.carolang.common.ast_nodes.MatchNode;
import com.carolang.common.ast_nodes.MatchStatementVariableNode;
import com.carolang.common.ast_nodes.Node;
import com.carolang.common.ast_nodes.NonValueNode;
import com.carolang.common.ast_nodes.RecursiveReferenceNode;
import com.google.common.collect.Sets;

public class constructionProgram extends ProgramBase {

    // These Rewrite rules are only the ones custom generated by the program -
    // ERASER and DUP rules already exist (and since they have a wildcard it
    // wouldn't really make sense to generate custom rules for them)
    // We also dont need to generate rules for INTEGER nodes and the built in
    // functions

    // TODO: the static stuff is only really in this class for legacy reasons
    // Maybe should move to AgentType.java?
    private Set<RewriteRule> rules = new HashSet<>();

    @Override
    public Set<RewriteRule> getRules() {
        return rules;
    }

    // For some reason the interpretor implements these as dataAgentImplementations
    // Fine for testing but isn't how the runtime is going to do it so bit odd
    // Not a high priority fix
    private static NonDataAgentType TrueAgent = new NonDataAgentType(0, "TRUE", null);
    private static NonDataAgentType FalseAgent = new NonDataAgentType(0, "FALSE", null);

    public static NonDataAgentType getTrueAgentType() {
        return TrueAgent;
    }

    public static NonDataAgentType getFalseAgentType() {
        return FalseAgent;
    }

    private static DataAgentType IntegerAgentType = new DataAgentType(0, "INTEGER", null, "intDataAgent",
            "allocateIntAgent", "int");

    private static DataAgentType FloatAgentType = new DataAgentType(0, "FLOAT", null, "floatDataAgent",
            "allocateFloatAgent", "float");

    public static DataAgentType getIntegerAgentType() {
        return IntegerAgentType;
    }

    public static DataAgentType getFloatAgentType() {
        return FloatAgentType;
    }

    private constructionNet startingNet;

    @Override
    public RewriteRule getStartingRule() {
        return new RewriteRule(null, null, startingNet, Map.of(), Map.of());
    }

    public constructionProgram(Node lambdaTree) {

        startingNet = nodeToNet(lambdaTree);
    }

    private Map<Integer, NonDataAgentType> naryDuplicators = new HashMap<>();

    /**
     * Output Port is null, the first of the unattached ports is the input to DUP
     * everything else in unattached ports is a DUP output
     * 
     * @param FunctionArgInputPort This is an optional param for if you want the
     *                             principle port of the duplicator node to be a
     *                             function argument port
     */
    private constructionNet getNaryDuplicatorNet(int n) {
        if (n == 1) {
            Port p1 = new Port();
            Port p2 = new Port();
            Wire w = new Wire(p1, p2);
            List<Port> externalPorts = new ArrayList<>();

            externalPorts = List.of(p1, p2);

            return new constructionNet(Set.of(), Set.of(w), externalPorts, Map.of(), Map.of());
        }
        NonDataAgentType duplicatorType = getNaryDuplicator(n);
        List<Port> auxPorts = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            auxPorts.add(new Port());
        }
        Port principlePort = new Port();
        AgentImplementation duplicatorAgent = new AgentImplementation(new ArrayList<>(auxPorts), principlePort,
                duplicatorType);
        List<Port> externalPorts = new ArrayList<>();

        externalPorts.add(principlePort);

        externalPorts.addAll(auxPorts);
        return new constructionNet(Set.of(duplicatorAgent), Set.of(), externalPorts, Map.of(), Map.of());

    }

    private NonDataAgentType getNaryDuplicator(int n) {
        // assert(n > 1);//Don't want single duplicators
        // Allow single Duplicators and have later phase that squashes them

        if (naryDuplicators.containsKey(n)) {
            return naryDuplicators.get(n);
        } else {
            NonDataAgentType duplicator = new NonDataAgentType(n, "Duplicator_" + n, null, true);
            naryDuplicators.put(n, duplicator);
            return duplicator;
        }
    }

    private constructionNet nodeToNet(Node node) {
        if (node instanceof MagicNode mNode) {
            return MagicNode(mNode);
        } else if (node instanceof LambdaNode lNode) {
            return lambdaNode(lNode);
        } else if (node instanceof IntegerNode iNode) {
            return IntegerNet(iNode);
        } else if (node instanceof FloatNode fNode) {
            return FloatNet(fNode);
        } else if (node instanceof FunctionNode fNode) {
            return FunctionNet(fNode);
        } else if (node instanceof FunctionArgumentNode faNode) {
            return FunctionArgumentNet(faNode);
        } else if (node instanceof RecursiveReferenceNode rrNode) {
            return RecursiveReferenceNet(rrNode);
        } else if (node instanceof IfNode ifNode) {
            return IfNet(ifNode);
        } else if (node instanceof BooleanNode bNode) {
            return BooleanNet(bNode);
        } else if (node instanceof EmptyListNode) {
            return EmptyListNet();
        } else if (node instanceof ConsNode cNode) {
            return ConsNet(cNode);
        } else if (node instanceof MatchNode mNode) {
            return MatchNet(mNode);
        } else if (node instanceof MatchStatementVariableNode mNode) {
            return MatchVarNet(mNode);
        }
        throw new UnsupportedOperationException("Not implemented yet");
    }

    private static int NextMatchID;

    private constructionNet lambdaNode(LambdaNode lNode) {
        constructionNet functionNet = nodeToNet(lNode.getFunction());
        constructionNet argumentNet = nodeToNet(lNode.getArgument());
        Map<Port, Port> portMappings = new HashMap<>();

        for (int i = 0; i < functionNet.getExternalFacingPorts().size()
                && i < argumentNet.getExternalFacingPorts().size(); i++) {
            portMappings.put(functionNet.getExternalFacingPorts().get(i), argumentNet.getExternalFacingPorts().get(i));
        }
        return constructionNet.Merge(List.of(functionNet, argumentNet), portMappings);
    }

    private constructionNet MatchNet(MatchNode node) {
        // emit one rule for cons one for []

        constructionNet netForEmptyCase = nodeToNet(node.getEmptyCase());

        // RewriteRule rule = new RewriteRule(, null, netForEmptyCase)

        constructionNet netForConsCase = nodeToNet(node.getNonEmptyCase());

        int resultsExternalPortCount = netForEmptyCase.getExternalFacingPorts().size();
        assert (resultsExternalPortCount == netForConsCase.getExternalFacingPorts().size());
        NonDataAgentType matchType = new NonDataAgentType(resultsExternalPortCount, "MATCH%d".formatted(NextMatchID++),
                node.getSourceFilePosition());
        Map<Integer, Port> emptyAgent1Index = new HashMap<>();
        for (int i = 0; i < resultsExternalPortCount; i++) {
            emptyAgent1Index.put(i, netForEmptyCase.getExternalFacingPorts().get(i));
        }
        RewriteRule emptyRule = new RewriteRule(matchType, EmptyListAgentType, netForEmptyCase, emptyAgent1Index,
                Map.of());
        rules.add(emptyRule);

        Map<Port, BindingBase> functionArgumentPortMapForConsCase = new HashMap<>(
                netForConsCase.getFunctionArgumentPortMap());

        Map<MatchBinding, List<Port>> portsWeNeedToBind = new HashMap<>();
        // TODO: likely need to actually initialise with all the things we are expecting
        // As we need to add ERASERS to ones that aren't used
        // So looping over the ones that are used doesn't quite work
        portsWeNeedToBind.put(new MatchBinding(node, 0, false), new ArrayList<Port>());

        for (int i = 0; i < resultsExternalPortCount; i++) {
            portsWeNeedToBind.put(new MatchBinding(node, i, true), new ArrayList<Port>());
        }

        for (Entry<Port, BindingBase> entry : new HashSet<>(functionArgumentPortMapForConsCase.entrySet())) {
            if (entry.getValue() instanceof MatchBinding mBinding && mBinding.getMatchNode() == node) {
                assert (portsWeNeedToBind.containsKey(mBinding));
                portsWeNeedToBind.get(mBinding).add(entry.getKey());

                functionArgumentPortMapForConsCase.remove(entry.getKey());
            }
        }
        // We want to bundle just the bindings that are for this match statement
        // Other variables can remain unbundled here
        // Now for each set of ports create a duplicator going to them and mark the
        // principle port of the dup as where that binding goes
        Map<MatchBinding, Port> bindingsThisMatchStatementMustDo = new HashMap<>();
        constructionNet boundNetForConsCase = netForConsCase;
        for (Entry<MatchBinding, List<Port>> entry : portsWeNeedToBind.entrySet()) {
            List<Port> portsList = entry.getValue();
            MatchBinding binding = entry.getKey();
            constructionNet duplicatorNet = getNaryDuplicatorNet(portsList.size());
            List<Port> duplicatorExternalPorts = duplicatorNet.getExternalFacingPorts();
            Map<Port, Port> portMappings = new HashMap<>();
            for (int i = 0; i < portsList.size(); i++) {
                portMappings.put(duplicatorExternalPorts.get(i + 1), portsList.get(i));
            }
            bindingsThisMatchStatementMustDo.put(binding, duplicatorExternalPorts.get(0));
            boundNetForConsCase = constructionNet.Merge(List.of(boundNetForConsCase, duplicatorNet), portMappings);
        }

        // So we are reacting with cons.
        // The 0th port of cons needs to get the Tail bindings attached
        // Note there will be only one tail binding as it cant be function type
        Map<Integer, Port> agent2IndexForConsCase = new HashMap<>();
        for (Entry<MatchBinding, Port> entry : bindingsThisMatchStatementMustDo.entrySet()) {
            MatchBinding binding = entry.getKey();
            Port port = entry.getValue();
            if (binding.isHead()) {
                agent2IndexForConsCase.put(binding.externalPort + 1, port);
            } else {
                assert (binding.externalPort == 0);
                agent2IndexForConsCase.put(0, port);
            }
        }
        Map<Integer, Port> agent1IndexForConsCase = new HashMap<>();
        for (int i = 0; i < netForConsCase.getExternalFacingPorts().size(); i++) {
            agent1IndexForConsCase.put(i, netForConsCase.getExternalFacingPorts().get(i));
        }

        AgentType ConsAgentType = getConsAgentType(agent2IndexForConsCase.size());
        RewriteRule consRule = new RewriteRule(matchType, ConsAgentType, boundNetForConsCase, agent1IndexForConsCase,
                agent2IndexForConsCase);

        rules.add(consRule);

        List<Port> auxPorts = new ArrayList<>();
        for (int i = 0; i < agent1IndexForConsCase.size(); i++) {
            auxPorts.add(new Port());
        }

        AgentImplementation matchAgent = new AgentImplementation(auxPorts, new Port(), matchType);
        List<Port> externalPorts = new ArrayList<>();
        externalPorts.add(matchAgent.getPrinciplePort());
        externalPorts.addAll(auxPorts);

        constructionNet matchNet = new constructionNet(Set.of(matchAgent), Set.of(), externalPorts,
                functionArgumentPortMapForConsCase, Map.of());

        constructionNet expressionNet = nodeToNet(node.getExpressionBeingMatched());

        Map<Port, Port> portMappings = Map.of(expressionNet.getOutputPort(), matchNet.getOutputPort());

        return constructionNet.Merge(List.of(matchNet, expressionNet), portMappings);

    }

    private constructionNet MatchVarNet(MatchStatementVariableNode node) {
        int externalPortCount = functionNodeExternalPortCount(node.getType()) + 1;
        Set<Wire> wires = new HashSet<Wire>();
        Map<Port, BindingBase> bindings = new HashMap<>();
        List<Port> externalPorts = new ArrayList<>();

        for (int i = 0; i < externalPortCount; i++) {
            Port matchBindingPort = new Port();
            Port externalPort = new Port();
            wires.add(new Wire(externalPort, matchBindingPort));
            MatchBinding binding = new MatchBinding(node.getMatchStatement(), i, node.isHead());
            bindings.put(matchBindingPort, binding);
            externalPorts.add(externalPort);
        }

        return new constructionNet(Set.of(), wires, externalPorts,
                bindings, Map.of());

    }

    private Map<Integer, NonDataAgentType> consAgentsTypes = new HashMap<>();

    private NonDataAgentType getConsAgentType(int amountOfAuxPorts) {
        if (consAgentsTypes.containsKey(amountOfAuxPorts)) {
            return consAgentsTypes.get(amountOfAuxPorts);
        } else {
            NonDataAgentType consAgent = new NonDataAgentType(amountOfAuxPorts, "Cons", null);
            consAgentsTypes.put(amountOfAuxPorts, consAgent);
            return consAgent;
        }
    }

    private constructionNet ConsNet(ConsNode node) {
        // 0th aux of a Cons is to the next cons/empty list
        constructionNet headNet = nodeToNet(node.getHead());
        constructionNet tailNet = nodeToNet(node.getTail());
        assert (tailNet.getExternalFacingPorts().size() == 1);

        final constructionNet rawHeadAndTailNet = constructionNet.Merge(List.of(tailNet, headNet), Map.of());
        Map<Port, BindingBase> functionArgumentPortMap = new HashMap<>();
        final constructionNet HeadAndTailNet = bundleArgPorts(rawHeadAndTailNet, functionArgumentPortMap, null);

        // Head And Tail net has ports that want function args in its external ports
        NonDataAgentType ConsType = getConsAgentType(headNet.getExternalFacingPorts().size() + 1);

        List<Port> consAuxPorts = new ArrayList<>();
        for (int i = 0; i < ConsType.getAuxiliaryPortCount(); i++) {
            consAuxPorts.add(new Port());
        }
        AgentImplementation ConsAgent = new AgentImplementation(consAuxPorts, new Port(), ConsType);
        Wire wireToTail = new Wire(HeadAndTailNet.getOutputPort(), ConsAgent.getAuxillaryPorts().get(0));
        Set<Wire> newWires = new HashSet<>();
        newWires.add(wireToTail);
        for (int i = 1; i < ConsType.getAuxiliaryPortCount(); i++) {
            // 0th is the head
            newWires.add(
                    new Wire(ConsAgent.getAuxillaryPorts().get(i), HeadAndTailNet.getExternalFacingPorts().get(i)));
        }

        Set<AgentImplementationBase> agents = new HashSet<>();
        agents.add(ConsAgent);
        agents.addAll(HeadAndTailNet.getAgents());

        Set<Wire> wires = new HashSet<>();
        wires.addAll(HeadAndTailNet.getWires());
        wires.addAll(newWires);
        wires = Wire.flattenWires(wires);
        List<Port> externalPorts = List.of(ConsAgent.getPrinciplePort());
        constructionNet toReturn = new constructionNet(agents, wires, externalPorts, functionArgumentPortMap, Map.of());
        // toReturn = constructionNet.Merge(List.of(toReturn), Map.of());
        return toReturn;

    }

    private constructionNet EmptyListNet() {
        AgentImplementation emptyListAgent = new AgentImplementation(List.of(), new Port(), EmptyListAgentType);
        return new constructionNet(Set.of(emptyListAgent), Set.of(), List.of(emptyListAgent.getPrinciplePort()),
                Map.of(), Map.of());
    }

    private constructionNet FunctionArgumentNet(FunctionArgumentNode faNode) {

        Type argumentType = faNode.getType();
        FunctionType functionType = (FunctionType) faNode.getDefiningFunction().getType();
        assert (functionType.argumentType.equals(argumentType));
        int externalPortCount = functionNodeExternalPortCount(argumentType);
        // externalPortCount -= functionNodeExternalPortCount(outputType);

        Set<Wire> wires = new HashSet<Wire>();

        Map<Port, BindingBase> functionArgumentBindings = new HashMap<>();// = Map.of(inputPort,
                                                                          // binding);

        List<Port> externalPorts = new ArrayList<>();
        for (int i = 0; i < externalPortCount + 1; i++) {
            Port externalPort = new Port();
            Port functionBindingPort = new Port();
            wires.add(new Wire(externalPort, functionBindingPort));
            functionArgumentBindings.put(functionBindingPort,
                    new FunctionArgumentBinding(faNode.getDefiningFunction(), i));
            externalPorts.add(externalPort);
        }

        // Just a wire wiring a function argument port to the output

        return new constructionNet(Set.of(), wires, externalPorts,
                functionArgumentBindings, Map.of());

        // int externalPortCount = faNode.getType().getTopLevelArrowCount();

    }

    private long userDefinedFunctionCount = 0;

    private constructionNet FunctionNet(FunctionNode node) {
        final constructionNet rawFunctionDefinition = nodeToNet(node.getDefinition());

        Map<Port, BindingBase> portsThatNeedFunctionArgument = new HashMap<>();
        final constructionNet bundledDefinition = bundleArgPorts(rawFunctionDefinition, portsThatNeedFunctionArgument,
                node);
        // Need the output port to now be the correct function argument port
        // And demote the current output to first external

        int bindingCount = 0;

        Map<Integer, Port> positions = new HashMap<>();
        for (Entry<Port, BindingBase> entry : portsThatNeedFunctionArgument.entrySet()) {
            if (entry.getValue() instanceof FunctionArgumentBinding fBinding) {
                if (fBinding.getFunctionArgumentNode() == node) {
                    positions.put(fBinding.externalPort(), entry.getKey());
                    if (fBinding.externalPort() == 0) {
                        // newOutputPort = entry.getKey();
                    } else {
                        bindingCount++;
                    }
                }
            }
        }

        // final constructionNet outputAdjustedDefinition =
        // bundledDefinition.swapOutput(newOutputPort);
        final constructionNet outputAdjustedDefinition = bringArgumentPortsToFront(bundledDefinition, positions);
        NonDataAgentType functionAgentType;
        if (recursiveFunctionAgentTypes.containsKey(node)) {
            functionAgentType = recursiveFunctionAgentTypes.get(node);
            assert (functionAgentType
                    .getAuxiliaryPortCount() == outputAdjustedDefinition.getExternalFacingPorts().size() - 1);
        } else {
            functionAgentType = new NonDataAgentType(outputAdjustedDefinition.getExternalFacingPorts().size() - 1,
                    /*
                     * One aux port for each external port in Def + one aux port per function
                     * argument that isnt the one we are currently dealing with (that one will be
                     * principle/output port)
                     */
                    "User_Defined_Function_%d_VAR_EQ_%s".formatted(userDefinedFunctionCount++, node.getVarName()),
                    node.getSourceFilePosition());

        }
        Map<Integer, BindingBase> auxPortsThatNeedFunctionArgument = makeFunctionRule(functionAgentType,
                node, outputAdjustedDefinition, portsThatNeedFunctionArgument);
        Map<Node, Integer> newBindingCounts = new HashMap<>();
        newBindingCounts.putAll(rawFunctionDefinition.getFunctionBindingCounts());
        newBindingCounts.put(node, bindingCount);

        constructionNet functionAgentNet = makeFunctionAgentNet(functionAgentType, node,
                auxPortsThatNeedFunctionArgument, newBindingCounts);
        return functionAgentNet;
    }

    private constructionNet bringArgumentPortsToFront(constructionNet net, Map<Integer, Port> positions) {
        for (int i = positions.size() - 1; i >= 0; i--) {
            Port port = positions.get(i);
            net = net.swapOutput(port);
        }
        return net;
    }

    private Map<Integer, BindingBase> makeFunctionRule(AgentType functionAgentType,
            FunctionNode functionThisIsDefining,
            constructionNet definition, Map<Port, BindingBase> portsThatNeedFunctionArgument) {

        Map<Integer, BindingBase> auxPortsThatNeedFunctionArgument = new HashMap<>();
        Map<Integer, Port> auxPortMap = new HashMap<>();
        // First assign ports that Need Function Argument an aux port
        int NextAuxPortOnEnd = functionAgentType.getAuxiliaryPortCount() - 1;// Next aux port that has not been assigned
                                                                             // to map to something in rule

        // All ports that want to be connected to the current function need to be lined
        // up with its external ports
        // All remaining function argument ports need to retain their info of what
        // function argument binding they want
        int nextAuxPortFromStart = 0;
        Map<BindingBase, Integer> preDefinedFunctionArgumentAuxPortMappings = recursiveFunctionTypesArgumentMap
                .get(functionThisIsDefining);
        for (Port port : portsThatNeedFunctionArgument.keySet()) {
            if (port == definition.getExternalFacingPorts().get(0)) {

                continue; // This is the output port so will be the principle port of the function agent
            } else if (functionThisIsDefining == portsThatNeedFunctionArgument.get(port).getNode()) {
                int externalPortIndex = portsThatNeedFunctionArgument.get(port).externalPort();
                auxPortMap.put(externalPortIndex - 1, port);
                nextAuxPortFromStart++; // TODO: This is going to break when we don't use arguments I think?
            } else {
                if (preDefinedFunctionArgumentAuxPortMappings == null) {
                    auxPortMap.put(NextAuxPortOnEnd, port);
                    auxPortsThatNeedFunctionArgument.put(NextAuxPortOnEnd, portsThatNeedFunctionArgument.get(port));
                    NextAuxPortOnEnd--;
                } else {
                    assert (!auxPortMap.containsKey(
                            preDefinedFunctionArgumentAuxPortMappings.get(portsThatNeedFunctionArgument.get(port))));
                    auxPortMap.put(
                            preDefinedFunctionArgumentAuxPortMappings.get(portsThatNeedFunctionArgument.get(port)),
                            port);
                }
            }
        }

        List<Port> portsThatDontNeedFunctionArg = definition.getExternalFacingPorts().stream()
                .filter(p -> !portsThatNeedFunctionArgument.containsKey(p)).toList();
        portsThatDontNeedFunctionArg = new ArrayList<>(portsThatDontNeedFunctionArg);

        for (Port p : portsThatDontNeedFunctionArg) {
            assert (!auxPortMap.containsKey(nextAuxPortFromStart));
            auxPortMap.put(nextAuxPortFromStart, p);
            nextAuxPortFromStart++;
        }

        rules.add(new RewriteRule(functionAgentType, auxPortMap, definition));
        return auxPortsThatNeedFunctionArgument;
    }

    private constructionNet makeFunctionAgentNet(NonDataAgentType functionAgentType,
            FunctionNode functionThisIsDefining,
            Map<Integer, BindingBase> auxPortsThatNeedFunctionArgument, Map<Node, Integer> bindingCounts) {

        // This now needs to ensure if the function node was already defined (it is
        // recursive) then we place our function argument bindings in the right order

        int auxPortAgentCount = functionAgentType.getAuxiliaryPortCount();
        List<Port> auxPorts = new ArrayList<>();
        List<Port> externalPorts = new ArrayList<>();
        Port outputPort = new Port();
        externalPorts.add(outputPort);

        Map<Port, BindingBase> functionArgumentPorts = new HashMap<>();

        for (int i = 0; i < auxPortAgentCount; i++) {
            Port auxPort = new Port();
            auxPorts.add(auxPort);
            if (!auxPortsThatNeedFunctionArgument.containsKey(i)) {
                externalPorts.add(auxPort);
            } else {
                functionArgumentPorts.put(auxPort, auxPortsThatNeedFunctionArgument.get(i));
            }
        }

        AgentImplementation functionAgent = new AgentImplementation(auxPorts, outputPort, functionAgentType);

        return new constructionNet(Set.of(functionAgent), Set.of(), externalPorts, functionArgumentPorts,
                bindingCounts);
    }

    private int functionNodeExternalPortCount(Type argumentType) {
        if(argumentType instanceof ListType lType)
        {
            return functionNodeExternalPortCount(lType.elementType);
        }
        if (!(argumentType instanceof FunctionType)) {
            return 0;
        }

        List<Type> typeChain = argumentType.typeChain();// so if we have alpha -> (beta -> delta) -> gamma this is
                                                        // [alpha; (beta -> delta); gamma]
        int initialExternalPorts = typeChain.size() - 1;// However some types in the chain may have external ports of
                                                        // their own
        for (Type t : typeChain) {
            initialExternalPorts -= functionNodeExternalPortCount(t);
        }

        assert (initialExternalPorts >= 0);
        return initialExternalPorts;
    }

    private constructionNet bundleArgPorts(final constructionNet net,
            Map<Port, BindingBase> portsThatNeedFunctionArgument_Out,
            FunctionNode functionThisIsDefining) {

        // int functionNodeExternalPortCount =
        // functionNodeExternalPortCount(functionThisIsDefining.getType());
        Map<BindingBase, List<Port>> groupedFunctionArguments = new HashMap<BindingBase, List<Port>>();

        if (functionThisIsDefining != null) {
            // groupedFunctionArguments.put(new
            // FunctionArgumentBinding(functionThisIsDefining, 0),
            // new ArrayList<Port>());// Always want this one even if we end up with 0-DUP
            // node (ERASER)
            // // Can be null as if statements also use this without defining a function

            Type argumentType = ((FunctionType) functionThisIsDefining.getType()).argumentType;

            int externalPortsCountOfUnusedArg = functionNodeExternalPortCount(argumentType) + 1;
            for (int i = 0; i < externalPortsCountOfUnusedArg; i++) {
                groupedFunctionArguments.put(new FunctionArgumentBinding(functionThisIsDefining, i),
                        new ArrayList<Port>());
            }

        }

        for (Port argPort : net.getFunctionArgumentPortMap().keySet()) {
            BindingBase binding = net.getFunctionArgumentPortMap().get(argPort);

            if (groupedFunctionArguments.containsKey(binding)) {
                groupedFunctionArguments.get(binding).add(argPort);
            } else {
                List<Port> newList = new ArrayList<>();
                newList.add(argPort);
                groupedFunctionArguments.put(binding, newList);
            }
        }
        List<constructionNet> netsToMerge = new ArrayList<>();
        netsToMerge.add(net);
        Map<Port, Port> portMappings = new HashMap<>();
        for (BindingBase fNode : groupedFunctionArguments.keySet()) {
            List<Port> argumentUses = groupedFunctionArguments.get(fNode);
            constructionNet duplicatorNet = getNaryDuplicatorNet(argumentUses.size());

            List<Port> duplicatorAuxPorts = duplicatorNet.getExternalFacingPorts();
            for (int i = 0; i < argumentUses.size(); i++) {
                portMappings.put(argumentUses.get(i), duplicatorAuxPorts.get(i + 1));
            }
            portsThatNeedFunctionArgument_Out.put(duplicatorAuxPorts.get(0), fNode);
            netsToMerge.add(duplicatorNet);
        }

        constructionNet bundledNet = constructionNet.Merge(netsToMerge, portMappings);

        return bundledNet;
    }

    private constructionNet IntegerNet(IntegerNode node) {
        Port outputPort = new Port();
        DataSource dataSource = new ConstantData<Integer>(node.getValue());
        DataAgentImplementation Agent = new DataAgentImplementation(List.of(), outputPort, IntegerAgentType,
                dataSource);
        Set<AgentImplementationBase> agents = Set.of(Agent);
        Set<Wire> wires = Set.of();
        return new constructionNet(agents, wires, List.of(outputPort), Map.of(), Map.of());
    }

    private constructionNet FloatNet(FloatNode node) {
        Port outputPort = new Port();
        DataSource dataSource = new ConstantData<Float>(node.getValue());
        DataAgentImplementation Agent = new DataAgentImplementation(List.of(), outputPort, FloatAgentType,
                dataSource);
        Set<AgentImplementationBase> agents = Set.of(Agent);
        Set<Wire> wires = Set.of();
        return new constructionNet(agents, wires, List.of(outputPort), Map.of(), Map.of());
    }

    static int debugcount = 0;


    private constructionNet MagicNode(MagicNode node) {
        MagicNodeTag id = node.getTag();
        int auxCounts = MagicNode.getAuxiliaryPortCount(id);
        NonDataAgentType magicAgent = (NonDataAgentType) MagicAgentTypeFactory.getMagicAgentType(id);// In future I
                                                                                                     // suppose it is
                                                                                                     // possible that we
                                                                                                     // will allow
                                                                                                     // DataAgentTypes
                                                                                                     // here - if we
                                                                                                     // wanted to let
                                                                                                     // people directly
                                                                                                     // use a curried +
                                                                                                     // 4 for example
        Port principlePort = new Port();
        List<Port> auxPorts = new ArrayList<>();

        for (int i = 0; i < auxCounts; i++) {
            auxPorts.add(new Port());
        }
        AgentImplementation magicImplementation = new AgentImplementation(new ArrayList<Port>(auxPorts), principlePort,
                magicAgent);
        List<Port> externalPorts = new ArrayList<>();
        externalPorts.add(principlePort);
        externalPorts.addAll(auxPorts);
        return new constructionNet(Set.of(magicImplementation), Set.of(), externalPorts, Map.of(), Map.of());

    }

    private static int ifCount = 0;

    private constructionNet IfNet(IfNode ifNode) {
        final constructionNet rawTrueNet = nodeToNet(ifNode.getThen());
        final constructionNet rawFalseNet = nodeToNet(ifNode.getElse());
        final constructionNet conditionNet = nodeToNet(ifNode.getCondition());
        assert (conditionNet.getExternalFacingPorts().size() == 1);
        assert (rawTrueNet.getExternalFacingPorts().size() == rawFalseNet.getExternalFacingPorts().size());

        int totalExternalPortsInBranches = rawTrueNet.getExternalFacingPorts().size();
        Map<Port, BindingBase> trueFunctionPorts = new HashMap<>();
        Map<Port, BindingBase> falseFunctionPorts = new HashMap<>();

        final constructionNet trueNet = bundleArgPorts(rawTrueNet, trueFunctionPorts, null);
        final constructionNet falseNet = bundleArgPorts(rawFalseNet, falseFunctionPorts, null);

        // Map<FunctionArgumentBinding, List<UnlabelledPort>> groupedFunctionArguments =
        // new HashMap<FunctionArgumentBinding, List<UnlabelledPort>>();
        Set<BindingBase> functionArguments = Stream
                .concat(trueFunctionPorts.values().stream(), falseFunctionPorts.values().stream())
                .collect(Collectors.toSet());

        NonDataAgentType ifAgentType = new NonDataAgentType(totalExternalPortsInBranches
                /* Dont count branches output port (-1) but do count this output port (+1) */ + functionArguments
                        .size(),
                "IF_%d".formatted(ifCount++), ifNode.getSourceFilePosition());
        ArrayList<Port> auxPorts = new ArrayList<>();
        Port IfAgentPrincplePort = new Port();
        List<Port> externalPortsForIfAgentNet = new ArrayList<>();
        externalPortsForIfAgentNet.add(IfAgentPrincplePort);
        for (int i = 0; i < ifAgentType.getAuxiliaryPortCount(); i++) {
            Port p = new Port();
            externalPortsForIfAgentNet.add(p);
            auxPorts.add(p);
        }
        Map<BindingBase, Integer> functionArgumentToIfAgentAuxPort = new HashMap<>();
        int nextAuxPort = auxPorts.size() - 1;
        for (BindingBase fBinding : functionArguments) {
            functionArgumentToIfAgentAuxPort.put(fBinding, nextAuxPort);
            externalPortsForIfAgentNet.remove(auxPorts.get(nextAuxPort));
            nextAuxPort--;
        }

        createIfStatementBranchRule(trueNet, totalExternalPortsInBranches, trueFunctionPorts, functionArguments,
                ifAgentType,
                functionArgumentToIfAgentAuxPort, TrueAgent);

        createIfStatementBranchRule(falseNet, totalExternalPortsInBranches, falseFunctionPorts, functionArguments,
                ifAgentType,
                functionArgumentToIfAgentAuxPort, FalseAgent);

        // Then return net with If Agent and condition net
        AgentImplementation ifAgent = new AgentImplementation(new ArrayList<Port>(auxPorts), IfAgentPrincplePort,
                ifAgentType);
        Map<Port, Port> portMappings = new HashMap<>();
        portMappings.put(ifAgent.getPrinciplePort(), conditionNet.getExternalFacingPorts().get(0));

        Map<Port, BindingBase> functionArgumentPortMap = new HashMap<>();
        for (Entry<BindingBase, Integer> entry : functionArgumentToIfAgentAuxPort.entrySet()) {
            functionArgumentPortMap.put(auxPorts.get(functionArgumentToIfAgentAuxPort.get(entry.getKey())),
                    entry.getKey());
        }

        constructionNet ifAgentNet = new constructionNet(Set.of(ifAgent), Set.of(), externalPortsForIfAgentNet,
                functionArgumentPortMap, Map.of());

        constructionNet result = constructionNet.Merge(List.of(ifAgentNet, conditionNet), portMappings);

        return result;

    }

    private void createIfStatementBranchRule(final constructionNet trueNet, int totalExternalPortsInBranches,
            Map<Port, BindingBase> trueFunctionPorts,
            Set<BindingBase> functionArguments, AgentType ifAgentType,
            Map<BindingBase, Integer> functionArgumentToIfAgentAuxPort,
            AgentType booleanValueAgent) {
        // Make RewriteRule for True Case
        Map<Integer, Port> trueCasePortMappings = new HashMap<>();
        // Each external port gets mapped to the corresponding external port in the true
        // definition
        for (int i = 0; i < totalExternalPortsInBranches; i++) {
            trueCasePortMappings.put(i, trueNet.getExternalFacingPorts().get(i));
        }
        // Function ports get mapped in after and just need to make sure that in the net
        // produced for the IF Agent we have a map for function bindings
        // Function ports that aren't used need to have an eraser attached.
        // do we also want to perform dups here?
        Map<Port, Port> argumentMappings = new HashMap<Port, Port>();
        Map<BindingBase, Port> whereFunctionArgumentsAreInBundledNet = new HashMap<>();
        List<constructionNet> netsToMergeForArguments = new ArrayList<>();
        netsToMergeForArguments.add(trueNet);
        for (BindingBase fBinding : functionArguments) {
            Set<Port> portsNeedingThisBinding = trueFunctionPorts.entrySet().stream()
                    .filter(e -> e.getValue().equals(fBinding)).map(e -> e.getKey()).collect(Collectors.toSet());
            constructionNet duplicatorNet = getNaryDuplicatorNet(portsNeedingThisBinding.size());
            whereFunctionArgumentsAreInBundledNet.put(fBinding, duplicatorNet.getExternalFacingPorts().get(0));
            int count = 0;
            for (Port p : portsNeedingThisBinding) {
                argumentMappings.put(p, duplicatorNet.getExternalFacingPorts().get(count + 1));
                count++;
            }
            netsToMergeForArguments.add(duplicatorNet);
        }
        final constructionNet bundledTrueNet = constructionNet.Merge(netsToMergeForArguments, argumentMappings);
        for (BindingBase fBinding : functionArguments) {
            trueCasePortMappings.put(functionArgumentToIfAgentAuxPort.get(fBinding),
                    whereFunctionArgumentsAreInBundledNet.get(fBinding));
        }

        RewriteRule trueRule = new RewriteRule(ifAgentType, booleanValueAgent, bundledTrueNet, trueCasePortMappings,
                Map.of());
        rules.add(trueRule);
    }

    private constructionNet BooleanNet(BooleanNode bNode) {
        AgentImplementation agent = new AgentImplementation(new ArrayList<Port>(), new Port(),
                bNode.getValue() ? TrueAgent : FalseAgent);
        return new constructionNet(Set.of(agent), Set.of(), List.of((agent.getPrinciplePort())),
                Map.of(), Map.of());
    }

    private Map<FunctionNode, NonDataAgentType> recursiveFunctionAgentTypes = new HashMap<>();
    private Map<FunctionNode, Map<BindingBase, Integer>> recursiveFunctionTypesArgumentMap = new HashMap<>();
    // So we need our recursively defined function node to agree on which aux ports
    // need which function args when we get to the original function node

    private constructionNet RecursiveReferenceNet(RecursiveReferenceNode node) {
        Set<BindingBase> functionBindingsNeeded = functionArgumentBindingsNeededInRecursiveNode(
                node.getDefinition(), new HashSet<>());
        NonDataAgentType agentType;
        FunctionNode function = node.getDefinition();
        if (recursiveFunctionAgentTypes.containsKey(function)) {
            agentType = recursiveFunctionAgentTypes.get(function);
        } else {
            int externalPortSize = functionNodeExternalPortCount(node.getType()) + functionBindingsNeeded.size(); // How
                                                                                                                  // do
                                                                                                                  // we
                                                                                                                  // calculate?
            agentType = new NonDataAgentType(externalPortSize,
                    "Recursive_Function_%d".formatted(userDefinedFunctionCount++),
                    node.getSourceFilePosition());
            recursiveFunctionAgentTypes.put(node.getDefinition(), agentType);
        }

        Port principlePort = new Port();
        List<Port> auxPorts = new ArrayList<>();
        for (int i = 0; i < agentType.getAuxiliaryPortCount(); i++) {
            auxPorts.add(new Port());
        }
        AgentImplementation agent = new AgentImplementation(new ArrayList<Port>(auxPorts), principlePort, agentType);
        List<Port> externalPorts = new ArrayList<>();
        externalPorts.add(principlePort);
        externalPorts.addAll(auxPorts);

        int NextExternalPort = auxPorts.size() - 1;
        Map<BindingBase, Integer> functionArgumentIndexedBindings = new HashMap<>();
        Map<Port, BindingBase> functionArgumentPortBindings = new HashMap<>();
        recursiveFunctionTypesArgumentMap.put(function, functionArgumentIndexedBindings);
        for (BindingBase fBinding : functionBindingsNeeded) {
            functionArgumentPortBindings.put(auxPorts.get(NextExternalPort), fBinding);
            functionArgumentIndexedBindings.put(fBinding, NextExternalPort);
            NextExternalPort--;
        }

        return new constructionNet(Set.of(agent), Set.of(), externalPorts, functionArgumentPortBindings, Map.of());

    }

    private Set<BindingBase> functionArgumentBindingsNeededInRecursiveNode(Node functionNode,
            Set<FunctionNode> doNotCount) {
        // Need to Not count any function Arguments whos lambda node is within the
        // function definition
        if (functionNode instanceof FunctionArgumentNode faNode && !doNotCount.contains(faNode.getDefiningFunction())) {
            int count = functionNodeExternalPortCount(faNode.getType()) + 1;
            HashSet<BindingBase> set = new HashSet<>();
            for (int i = 0; i < count; i++) {
                set.add(new FunctionArgumentBinding(faNode.getDefiningFunction(), i));
            }
            return set;
        }
        if (functionNode instanceof FunctionNode fNode) {
            doNotCount.add(fNode);
        }
        if (functionNode instanceof NonValueNode nvNode) {
            Set<BindingBase> set = Set.of();
            for (Node child : nvNode.getChildrenIterator()) {
                set = Sets.union(set, functionArgumentBindingsNeededInRecursiveNode(child, doNotCount));
            }
            return set;
        }
        return Set.of();

    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        String StartingNet = startingNet.toString();
        sb.append(String.format("{\"Starting Net\": %s,", StartingNet));
        sb.append("\"Rules\": [");
        String prefix = "";
        for (RewriteRule rule : rules) {
            sb.append(prefix);
            prefix = ",";
            sb.append(rule.toString());
        }
        sb.append("]}");
        return sb.toString();
    }
}